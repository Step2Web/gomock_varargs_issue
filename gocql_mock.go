// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/willfaught/gockle (interfaces: Session,Query)

// Package main is a generated GoMock package.
package main

import (
	context "context"
	reflect "reflect"

	gocql "github.com/gocql/gocql"
	gomock "github.com/golang/mock/gomock"
	gockle "github.com/willfaught/gockle"
)

// MockSession is a mock of Session interface.
type MockSession struct {
	ctrl     *gomock.Controller
	recorder *MockSessionMockRecorder
}

// MockSessionMockRecorder is the mock recorder for MockSession.
type MockSessionMockRecorder struct {
	mock *MockSession
}

// NewMockSession creates a new mock instance.
func NewMockSession(ctrl *gomock.Controller) *MockSession {
	mock := &MockSession{ctrl: ctrl}
	mock.recorder = &MockSessionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSession) EXPECT() *MockSessionMockRecorder {
	return m.recorder
}

// Batch mocks base method.
func (m *MockSession) Batch(arg0 gockle.BatchKind) gockle.Batch {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Batch", arg0)
	ret0, _ := ret[0].(gockle.Batch)
	return ret0
}

// Batch indicates an expected call of Batch.
func (mr *MockSessionMockRecorder) Batch(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Batch", reflect.TypeOf((*MockSession)(nil).Batch), arg0)
}

// Close mocks base method.
func (m *MockSession) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockSessionMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockSession)(nil).Close))
}

// Columns mocks base method.
func (m *MockSession) Columns(arg0, arg1 string) (map[string]gocql.TypeInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Columns", arg0, arg1)
	ret0, _ := ret[0].(map[string]gocql.TypeInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Columns indicates an expected call of Columns.
func (mr *MockSessionMockRecorder) Columns(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Columns", reflect.TypeOf((*MockSession)(nil).Columns), arg0, arg1)
}

// Exec mocks base method.
func (m *MockSession) Exec(arg0 string, arg1 ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Exec indicates an expected call of Exec.
func (mr *MockSessionMockRecorder) Exec(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockSession)(nil).Exec), varargs...)
}

// Query mocks base method.
func (m *MockSession) Query(arg0 string, arg1 ...interface{}) gockle.Query {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(gockle.Query)
	return ret0
}

// Query indicates an expected call of Query.
func (mr *MockSessionMockRecorder) Query(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockSession)(nil).Query), varargs...)
}

// Scan mocks base method.
func (m *MockSession) Scan(arg0 string, arg1 []interface{}, arg2 ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockSessionMockRecorder) Scan(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockSession)(nil).Scan), varargs...)
}

// ScanIterator mocks base method.
func (m *MockSession) ScanIterator(arg0 string, arg1 ...interface{}) gockle.Iterator {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ScanIterator", varargs...)
	ret0, _ := ret[0].(gockle.Iterator)
	return ret0
}

// ScanIterator indicates an expected call of ScanIterator.
func (mr *MockSessionMockRecorder) ScanIterator(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanIterator", reflect.TypeOf((*MockSession)(nil).ScanIterator), varargs...)
}

// ScanMap mocks base method.
func (m *MockSession) ScanMap(arg0 string, arg1 map[string]interface{}, arg2 ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ScanMap", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ScanMap indicates an expected call of ScanMap.
func (mr *MockSessionMockRecorder) ScanMap(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanMap", reflect.TypeOf((*MockSession)(nil).ScanMap), varargs...)
}

// ScanMapSlice mocks base method.
func (m *MockSession) ScanMapSlice(arg0 string, arg1 ...interface{}) ([]map[string]interface{}, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ScanMapSlice", varargs...)
	ret0, _ := ret[0].([]map[string]interface{})
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ScanMapSlice indicates an expected call of ScanMapSlice.
func (mr *MockSessionMockRecorder) ScanMapSlice(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanMapSlice", reflect.TypeOf((*MockSession)(nil).ScanMapSlice), varargs...)
}

// ScanMapTx mocks base method.
func (m *MockSession) ScanMapTx(arg0 string, arg1 map[string]interface{}, arg2 ...interface{}) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ScanMapTx", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ScanMapTx indicates an expected call of ScanMapTx.
func (mr *MockSessionMockRecorder) ScanMapTx(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanMapTx", reflect.TypeOf((*MockSession)(nil).ScanMapTx), varargs...)
}

// Tables mocks base method.
func (m *MockSession) Tables(arg0 string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Tables", arg0)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Tables indicates an expected call of Tables.
func (mr *MockSessionMockRecorder) Tables(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tables", reflect.TypeOf((*MockSession)(nil).Tables), arg0)
}

// MockQuery is a mock of Query interface.
type MockQuery struct {
	ctrl     *gomock.Controller
	recorder *MockQueryMockRecorder
}

// MockQueryMockRecorder is the mock recorder for MockQuery.
type MockQueryMockRecorder struct {
	mock *MockQuery
}

// NewMockQuery creates a new mock instance.
func NewMockQuery(ctrl *gomock.Controller) *MockQuery {
	mock := &MockQuery{ctrl: ctrl}
	mock.recorder = &MockQueryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQuery) EXPECT() *MockQueryMockRecorder {
	return m.recorder
}

// Exec mocks base method.
func (m *MockQuery) Exec() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exec")
	ret0, _ := ret[0].(error)
	return ret0
}

// Exec indicates an expected call of Exec.
func (mr *MockQueryMockRecorder) Exec() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockQuery)(nil).Exec))
}

// Iter mocks base method.
func (m *MockQuery) Iter() gockle.Iterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Iter")
	ret0, _ := ret[0].(gockle.Iterator)
	return ret0
}

// Iter indicates an expected call of Iter.
func (mr *MockQueryMockRecorder) Iter() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Iter", reflect.TypeOf((*MockQuery)(nil).Iter))
}

// MapScan mocks base method.
func (m *MockQuery) MapScan(arg0 map[string]interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MapScan", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// MapScan indicates an expected call of MapScan.
func (mr *MockQueryMockRecorder) MapScan(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MapScan", reflect.TypeOf((*MockQuery)(nil).MapScan), arg0)
}

// PageSize mocks base method.
func (m *MockQuery) PageSize(arg0 int) gockle.Query {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PageSize", arg0)
	ret0, _ := ret[0].(gockle.Query)
	return ret0
}

// PageSize indicates an expected call of PageSize.
func (mr *MockQueryMockRecorder) PageSize(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PageSize", reflect.TypeOf((*MockQuery)(nil).PageSize), arg0)
}

// PageState mocks base method.
func (m *MockQuery) PageState(arg0 []byte) gockle.Query {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PageState", arg0)
	ret0, _ := ret[0].(gockle.Query)
	return ret0
}

// PageState indicates an expected call of PageState.
func (mr *MockQueryMockRecorder) PageState(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PageState", reflect.TypeOf((*MockQuery)(nil).PageState), arg0)
}

// Release mocks base method.
func (m *MockQuery) Release() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Release")
}

// Release indicates an expected call of Release.
func (mr *MockQueryMockRecorder) Release() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Release", reflect.TypeOf((*MockQuery)(nil).Release))
}

// Scan mocks base method.
func (m *MockQuery) Scan(arg0 ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockQueryMockRecorder) Scan(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockQuery)(nil).Scan), arg0...)
}

// WithContext mocks base method.
func (m *MockQuery) WithContext(arg0 context.Context) gockle.Query {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithContext", arg0)
	ret0, _ := ret[0].(gockle.Query)
	return ret0
}

// WithContext indicates an expected call of WithContext.
func (mr *MockQueryMockRecorder) WithContext(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithContext", reflect.TypeOf((*MockQuery)(nil).WithContext), arg0)
}
